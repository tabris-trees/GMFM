
function Compute(est_theta,est_phi,Gauss_efficient,order)
%INVERSE function to compute the X,Y,Z component of given position
%   n_theta: The point of theta grid
%   n_phi: The point of phi grid
%   Gauss_efficient: Gauss Efficient
%   order: Degree of truncation
    
    % Building a global grid
    i = 0;
    B_grid = zeros(length(est_theta)*length(est_phi),1);
    
    for ix = est_theta
        for iy = est_phi
            i = i+1;
            B_grid(i,1) = ix;
            B_grid(i,2) = iy;
        end
    end
    
    % Compute the data on the grid points
    est_data = ComputeXYZ(B_grid,Gauss_efficient,order);
    
    % Save the results
    writematrix(est_data,'MMD_20200305_global.txt','Delimiter','tab');
end





function [est_data] = ComputeXYZ(B_gird,GE,order)
%INVERSE function to compute the X,Y,Z component of given position
%   B_grid: the position of given point
%   GE: Gauss coefficient generated by function "Inverse.m"
    number_station = length(B_gird);
    rad = pi/180;
    
    est_data = zeros(number_station,9);
    
    for xx = 1:number_station
        theta = (90-B_gird(xx,1))*rad;
        phi = (B_gird(xx,2)-180)*rad;
    
        kernel_matrix_station = KM(phi,theta,order);
        est_data(xx,1) = B_gird(xx,1); % latitude
        est_data(xx,2) = B_gird(xx,2); % longitude
        X = kernel_matrix_station(1,:)*GE; % X
        Y = kernel_matrix_station(2,:)*GE; % Y
        Z = kernel_matrix_station(3,:)*GE; % Z
        D = atan(Y./X);
        H = sqrt(X.^2+Y.^2);
        I = atan(Z./H);
        F = sqrt(X.^2+Y.^2+Z.^2);
        est_data(xx,3) = X;
        est_data(xx,4) = Y;
        est_data(xx,5) = Z;
        est_data(xx,6) = -Z; % Br
        est_data(xx,7) = D; % D
        est_data(xx,8) = I; % I
        est_data(xx,9) = F; % F
    end
end